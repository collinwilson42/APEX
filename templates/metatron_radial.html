<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>METATRON - Radial Time-Capsule Database</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <style>
        :root {
            --color-base-core: #0a0b0d;
            --color-base-secondary: #12141a;
            --color-base-tertiary: #1a1d24;
            --color-base-elevated: #22262f;
            --color-torus-bg: #050608;
            
            --color-mint: #ADEBB3;
            --color-teal: #20B2AA;
            --color-blue: #6B8DD6;
            --color-magenta: #C084FC;
            --color-golden: #D4AF37;
            --color-red: #ff6b6b;
            
            --color-text-primary: #F2F4F7;
            --color-text-secondary: #A4A9B3;
            --color-text-tertiary: #6B7280;
            
            --font-sans: 'Inter', -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
            
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 16px;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: var(--font-sans);
            background: var(--color-base-core);
            color: var(--color-text-primary);
            min-height: 100vh;
            overflow: hidden;
        }
        
        #root {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        /* HEADER */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: linear-gradient(180deg, var(--color-base-secondary) 0%, var(--color-base-core) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.04);
            flex-shrink: 0;
        }
        
        .header-left { display: flex; align-items: center; gap: 16px; }
        .header-title { display: flex; align-items: center; gap: 10px; }
        .header-title__icon {
            width: 28px; height: 28px;
            display: flex; align-items: center; justify-content: center;
            background: linear-gradient(145deg, rgba(192,132,252,0.15), rgba(192,132,252,0.05));
            border-radius: var(--radius-sm);
            color: var(--color-magenta);
        }
        .header-title__text { font-size: 15px; font-weight: 600; }
        .header-title__badge {
            font-size: 10px; font-weight: 500;
            color: var(--color-magenta);
            background: rgba(192,132,252,0.12);
            padding: 3px 8px; border-radius: 4px;
        }
        
        .arm-control {
            display: flex; align-items: center; gap: 16px;
            padding: 8px 16px;
            background: linear-gradient(145deg, var(--color-base-tertiary), var(--color-base-secondary));
            border-radius: var(--radius-md);
            border: 1px solid rgba(255,255,255,0.04);
        }
        .arm-stat { display: flex; align-items: center; gap: 6px; }
        .arm-stat__label { font-size: 11px; color: var(--color-text-tertiary); font-weight: 500; }
        .arm-stat__value { font-family: var(--font-mono); font-size: 12px; color: var(--color-magenta); min-width: 40px; }
        .arm-stat input[type="range"] {
            width: 80px; height: 4px;
            background: var(--color-base-core);
            border-radius: 2px; outline: none;
            -webkit-appearance: none;
        }
        .arm-stat input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px; height: 14px;
            background: var(--color-magenta);
            border-radius: 50%; cursor: pointer;
            box-shadow: 0 0 8px rgba(192,132,252,0.5);
        }
        
        .header-stats { display: flex; gap: 16px; }
        .header-stat { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--color-text-tertiary); }
        .header-stat-value { font-family: var(--font-mono); color: var(--color-teal); }

        /* MAIN LAYOUT */
        .main-container {
            display: grid;
            grid-template-rows: 1fr 320px;
            flex: 1;
            overflow: hidden;
        }
        
        .top-panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            overflow: hidden;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        
        .panel {
            display: flex;
            flex-direction: column;
            background: var(--color-base-secondary);
            overflow: hidden;
        }
        .panel:first-child { border-right: 1px solid rgba(255,255,255,0.04); }
        
        .panel-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 14px 18px;
            background: linear-gradient(180deg, var(--color-base-tertiary) 0%, var(--color-base-secondary) 100%);
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }
        .panel-header__left { display: flex; align-items: center; gap: 12px; }
        .panel-back {
            display: flex; align-items: center; justify-content: center;
            width: 28px; height: 28px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.08);
            border-radius: var(--radius-sm);
            color: var(--color-text-tertiary);
            cursor: pointer; transition: all 0.15s ease;
            opacity: 0; pointer-events: none;
        }
        .panel-back.visible { opacity: 1; pointer-events: auto; }
        .panel-back:hover { background: rgba(255,255,255,0.05); color: var(--color-text-primary); }
        
        .panel-title { font-size: 13px; font-weight: 600; letter-spacing: 0.5px; text-transform: uppercase; }
        .panel-title--sync { color: var(--color-mint); }
        .panel-title--integration { color: var(--color-blue); }
        
        .panel-badge {
            font-size: 10px; font-weight: 500;
            padding: 3px 8px; border-radius: 4px;
            background: rgba(173,235,179,0.12);
            color: var(--color-mint);
        }
        .panel-badge--blue { background: rgba(107,141,214,0.12); color: var(--color-blue); }
        
        .panel-header__right { display: flex; align-items: center; gap: 8px; }
        .panel-stat { font-size: 10px; color: var(--color-text-tertiary); font-family: var(--font-mono); }
        
        .panel-content {
            flex: 1; overflow-y: auto; padding: 16px;
        }
        .panel-content::-webkit-scrollbar { width: 6px; }
        .panel-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }
        .panel-content::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }

        /* TORUS ENGINE PANEL */
        .torus-panel {
            background: var(--color-torus-bg);
            border-top: 1px solid rgba(212,175,55,0.2);
            display: flex;
            flex-direction: column;
            height: 320px;
            position: relative;
        }
        
        .torus-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 18px;
            background: linear-gradient(180deg, rgba(10,11,13,0.95) 0%, rgba(5,6,8,0.9) 100%);
            border-bottom: 1px solid rgba(212,175,55,0.15);
            position: relative;
            z-index: 10;
        }
        .torus-header__left { display: flex; align-items: center; gap: 12px; }
        .torus-title {
            font-size: 12px; font-weight: 600;
            letter-spacing: 0.8px; text-transform: uppercase;
            color: var(--color-golden);
            text-shadow: 0 0 10px rgba(212,175,55,0.5);
        }
        .torus-subtitle {
            font-size: 9px; color: var(--color-text-tertiary);
            font-family: var(--font-mono);
            background: rgba(0,0,0,0.5);
            padding: 3px 8px; border-radius: 4px;
        }
        .torus-controls { display: flex; align-items: center; gap: 12px; }
        .torus-stat { display: flex; align-items: center; gap: 5px; font-size: 10px; color: var(--color-text-tertiary); }
        .torus-stat__value { font-family: var(--font-mono); color: var(--color-golden); font-weight: 600; }
        
        .torus-viz {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #torusCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
        
        .torus-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            z-index: 5;
        }
        .torus-overlay__icon { font-size: 48px; opacity: 0.15; margin-bottom: 12px; }
        .torus-overlay__text { font-size: 14px; font-weight: 500; color: var(--color-text-tertiary); opacity: 0.5; }

        /* NODE CARDS */
        .node-card {
            position: relative;
            padding: 14px 16px; margin-bottom: 10px;
            background: linear-gradient(145deg, var(--color-base-tertiary), var(--color-base-secondary));
            border: 1px solid rgba(255,255,255,0.04);
            border-radius: var(--radius-md);
            cursor: pointer; transition: all 0.15s ease;
        }
        .node-card:hover {
            background: linear-gradient(145deg, var(--color-base-elevated), var(--color-base-tertiary));
            border-color: rgba(255,255,255,0.08);
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }
        .node-card--active {
            border-color: var(--color-magenta);
            box-shadow: 0 0 0 1px var(--color-magenta), 0 4px 20px rgba(192,132,252,0.2);
        }
        .node-card--sync { border-left: 3px solid var(--color-mint); }
        .node-card--integration { border-left: 3px solid var(--color-blue); }
        
        .node-card__header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
        .node-card__id { font-family: var(--font-mono); font-size: 13px; font-weight: 600; }
        .node-card__coords {
            font-family: var(--font-mono); font-size: 10px;
            color: var(--color-text-tertiary);
            background: rgba(0,0,0,0.3);
            padding: 3px 8px; border-radius: 4px;
        }
        .node-card__title { font-size: 12px; color: var(--color-text-secondary); margin-bottom: 10px; line-height: 1.4; }
        .node-card__meta { display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
        .node-card__tag {
            font-size: 10px; font-weight: 500;
            padding: 3px 8px; border-radius: 4px;
            text-transform: uppercase; letter-spacing: 0.3px;
        }
        .node-card__tag--zone { background: rgba(32,178,170,0.12); color: var(--color-teal); }
        .node-card__tag--status { background: rgba(173,235,179,0.12); color: var(--color-mint); }
        .node-card__tag--pending { background: rgba(255,193,7,0.12); color: #FFC107; }
        .node-card__tag--w-layer { background: rgba(192,132,252,0.12); color: var(--color-magenta); }

        .tree-header { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid rgba(255,255,255,0.04); }
        .tree-breadcrumb { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--color-text-tertiary); }
        .tree-breadcrumb__item { padding: 4px 8px; background: rgba(255,255,255,0.04); border-radius: 4px; cursor: pointer; transition: all 0.15s ease; }
        .tree-breadcrumb__item:hover { background: rgba(255,255,255,0.08); color: var(--color-text-primary); }
        .tree-breadcrumb__item--active { background: rgba(192,132,252,0.15); color: var(--color-magenta); }
        .tree-breadcrumb__sep { color: var(--color-text-tertiary); opacity: 0.5; }

        .empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 48px 24px; text-align: center; }
        .empty-state__icon {
            width: 64px; height: 64px;
            display: flex; align-items: center; justify-content: center;
            background: linear-gradient(145deg, var(--color-base-tertiary), var(--color-base-secondary));
            border-radius: 50%; margin-bottom: 16px;
            color: var(--color-text-tertiary);
        }
        .empty-state__title { font-size: 14px; font-weight: 500; color: var(--color-text-secondary); margin-bottom: 6px; }
        .empty-state__subtitle { font-size: 12px; color: var(--color-text-tertiary); line-height: 1.5; }

        .insight-indicator {
            position: absolute; top: 10px; right: 10px;
            width: 8px; height: 8px; border-radius: 50%;
            background: var(--color-golden);
            box-shadow: 0 0 8px var(--color-golden);
        }
        .insight-indicator--pending {
            background: #FFC107;
            box-shadow: 0 0 8px #FFC107;
            animation: pulse 1.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;
        
        // DEMO DATA
        const DEMO_SYNC_NODES = [
            { id: '8.0', title: 'UI/UX Architecture', zone: 'sync', ring: 1.000, theta: 45, w: 0, status: 'active', hasInsights: true },
            { id: '8.1', title: 'Control Panel System', zone: 'sync', ring: 1.000, theta: 67.5, w: 0, status: 'active', hasInsights: false },
            { id: '8.2', title: 'Radial Visualization', zone: 'sync', ring: 1.000, theta: 90, w: 0, status: 'active', hasInsights: true },
            { id: '9.0', title: 'Python Integration', zone: 'sync', ring: 1.000, theta: 135, w: 0, status: 'active', hasInsights: false },
            { id: '9.1', title: 'Position Calculator', zone: 'sync', ring: 1.000, theta: 157.5, w: 0, status: 'active', hasInsights: true },
            { id: '10.0', title: 'Database Schema', zone: 'sync', ring: 1.000, theta: 225, w: 1, status: 'superseded', hasInsights: false },
        ];
        
        const DEMO_INTEGRATION_NODES = [
            { id: 'CN-7.1', title: 'position_calculator.py', zone: 'code', ring: 0.500, theta: 157.5, w: 0, status: 'active', parent: '9.1', pendingInsight: true },
            { id: 'CN-9.2', title: 'RadialDatabase.jsx', zone: 'code', ring: 0.500, theta: 90, w: 0, status: 'active', parent: '8.2', pendingInsight: false },
            { id: 'CN-8.1', title: 'ControlPanel.jsx', zone: 'code', ring: 0.500, theta: 67.5, w: 0, status: 'active', parent: '8.1', pendingInsight: true },
            { id: 'UM-7.1', title: 'radial_core_module', zone: 'module', ring: 0.382, theta: 135, w: 0, status: 'pending', parent: 'CN-7.1', pendingInsight: false },
        ];
        
        // ═══════════════════════════════════════════════════════════════════════════
        // TORUS ENGINE - Electronic Realism Plasma Containment Field
        // ═══════════════════════════════════════════════════════════════════════════
        function TorusEngine() {
            const containerRef = useRef(null);
            const canvasRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const animationRef = useRef(null);
            const particlesRef = useRef(null);
            const torusRef = useRef(null);
            const nodesRef = useRef([]);
            const timeRef = useRef(0);
            
            const [error, setError] = useState(null);
            const [isLoaded, setIsLoaded] = useState(false);
            const [particleCount, setParticleCount] = useState(0);
            
            useEffect(() => {
                if (typeof THREE === 'undefined') {
                    setError('Three.js not loaded');
                    return;
                }
                
                const initTimer = setTimeout(() => {
                    try {
                        initTorusEngine();
                    } catch (e) {
                        console.error('TORUS ENGINE ERROR:', e);
                        setError(e.message);
                    }
                }, 150);
                
                return () => {
                    clearTimeout(initTimer);
                    if (animationRef.current) cancelAnimationFrame(animationRef.current);
                    if (rendererRef.current) rendererRef.current.dispose();
                };
            }, []);
            
            const initTorusEngine = () => {
                console.log('TORUS ENGINE: Initializing Plasma Containment Field...');
                
                const container = containerRef.current;
                const canvas = canvasRef.current;
                if (!container || !canvas) return;
                
                const width = container.clientWidth || 800;
                const height = container.clientHeight || 280;
                
                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x050608);
                scene.fog = new THREE.FogExp2(0x050608, 0.08);
                sceneRef.current = scene;
                
                // Camera - positioned to see torus from above-front angle
                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.set(0, 4, 9);
                camera.lookAt(0, 0, 0);
                
                // Renderer with better quality
                const renderer = new THREE.WebGLRenderer({ 
                    canvas, 
                    antialias: true, 
                    alpha: true,
                    powerPreference: 'high-performance'
                });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.2;
                rendererRef.current = renderer;
                
                // ═══════════════════════════════════════════════════════════════
                // CUSTOM FRESNEL SHADER MATERIAL - Plasma Glow Effect
                // ═══════════════════════════════════════════════════════════════
                const fresnelVertexShader = `
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        vViewPosition = -mvPosition.xyz;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;
                
                const fresnelFragmentShader = `
                    uniform float uTime;
                    uniform vec3 uColorCore;
                    uniform vec3 uColorRim;
                    uniform vec3 uColorPulse;
                    uniform float uPulseSpeed;
                    uniform float uFresnelPower;
                    
                    varying vec3 vNormal;
                    varying vec3 vViewPosition;
                    varying vec2 vUv;
                    
                    void main() {
                        // Fresnel calculation - rim lighting
                        vec3 viewDir = normalize(vViewPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDir, vNormal)), uFresnelPower);
                        
                        // Pulsing effect
                        float pulse = sin(uTime * uPulseSpeed) * 0.5 + 0.5;
                        float pulse2 = sin(uTime * uPulseSpeed * 0.7 + 1.5) * 0.5 + 0.5;
                        
                        // Flow along the torus tube
                        float flow = sin(vUv.x * 20.0 - uTime * 2.0) * 0.5 + 0.5;
                        float flow2 = sin(vUv.y * 8.0 + uTime * 1.5) * 0.5 + 0.5;
                        
                        // Color mixing
                        vec3 coreColor = uColorCore * (0.3 + flow * 0.2);
                        vec3 rimColor = uColorRim * fresnel * (0.8 + pulse * 0.4);
                        vec3 pulseColor = uColorPulse * pulse2 * flow2 * 0.3;
                        
                        vec3 finalColor = coreColor + rimColor + pulseColor;
                        
                        // Add plasma intensity at edges
                        float intensity = fresnel * (0.6 + pulse * 0.4);
                        finalColor += uColorRim * intensity * 0.5;
                        
                        // Alpha based on fresnel for transparency effect
                        float alpha = 0.4 + fresnel * 0.6;
                        
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `;
                
                // Torus with custom shader
                const torusGeometry = new THREE.TorusGeometry(3, 0.9, 64, 128);
                const torusMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0 },
                        uColorCore: { value: new THREE.Color(0x1a1a2e) },      // Dark blue core
                        uColorRim: { value: new THREE.Color(0xD4AF37) },        // Golden rim
                        uColorPulse: { value: new THREE.Color(0x20B2AA) },      // Teal pulse
                        uPulseSpeed: { value: 1.5 },
                        uFresnelPower: { value: 2.5 }
                    },
                    vertexShader: fresnelVertexShader,
                    fragmentShader: fresnelFragmentShader,
                    transparent: true,
                    side: THREE.DoubleSide,
                    depthWrite: false
                });
                
                const torus = new THREE.Mesh(torusGeometry, torusMaterial);
                torus.rotation.x = Math.PI / 5;
                scene.add(torus);
                torusRef.current = torus;
                
                // Inner glow torus (smaller, more intense)
                const innerGlowGeometry = new THREE.TorusGeometry(3, 0.5, 32, 64);
                const innerGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xD4AF37,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
                innerGlow.rotation.x = Math.PI / 5;
                scene.add(innerGlow);
                
                // ═══════════════════════════════════════════════════════════════
                // PARTICLE SYSTEM - Circulation Flow
                // ═══════════════════════════════════════════════════════════════
                const PARTICLE_COUNT = 2000;
                setParticleCount(PARTICLE_COUNT);
                
                const particleGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(PARTICLE_COUNT * 3);
                const colors = new Float32Array(PARTICLE_COUNT * 3);
                const sizes = new Float32Array(PARTICLE_COUNT);
                const phases = new Float32Array(PARTICLE_COUNT); // For varied animation
                
                const torusMajorRadius = 3;
                const torusMinorRadius = 0.9;
                
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    // Random position along torus tube
                    const u = Math.random() * Math.PI * 2; // Around the ring
                    const v = Math.random() * Math.PI * 2; // Around the tube
                    
                    // Store initial phase for animation
                    phases[i] = u;
                    
                    // Torus parametric position
                    const x = (torusMajorRadius + torusMinorRadius * Math.cos(v)) * Math.cos(u);
                    const y = torusMinorRadius * Math.sin(v);
                    const z = (torusMajorRadius + torusMinorRadius * Math.cos(v)) * Math.sin(u);
                    
                    // Apply torus tilt
                    const tiltAngle = Math.PI / 5;
                    positions[i * 3] = x;
                    positions[i * 3 + 1] = y * Math.cos(tiltAngle) - z * Math.sin(tiltAngle) * 0.3;
                    positions[i * 3 + 2] = y * Math.sin(tiltAngle) + z * Math.cos(tiltAngle);
                    
                    // Color variation: golden to teal
                    const colorMix = Math.random();
                    if (colorMix < 0.6) {
                        // Golden particles
                        colors[i * 3] = 0.83 + Math.random() * 0.1;
                        colors[i * 3 + 1] = 0.69 + Math.random() * 0.1;
                        colors[i * 3 + 2] = 0.22 + Math.random() * 0.1;
                    } else if (colorMix < 0.85) {
                        // Teal particles
                        colors[i * 3] = 0.13;
                        colors[i * 3 + 1] = 0.7 + Math.random() * 0.2;
                        colors[i * 3 + 2] = 0.67 + Math.random() * 0.2;
                    } else {
                        // Magenta accent particles
                        colors[i * 3] = 0.75 + Math.random() * 0.1;
                        colors[i * 3 + 1] = 0.52;
                        colors[i * 3 + 2] = 0.99;
                    }
                    
                    sizes[i] = 0.02 + Math.random() * 0.04;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                particleGeometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                
                // Custom particle shader for glow effect
                const particleVertexShader = `
                    attribute float size;
                    attribute float phase;
                    varying vec3 vColor;
                    varying float vPhase;
                    
                    void main() {
                        vColor = color;
                        vPhase = phase;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `;
                
                const particleFragmentShader = `
                    varying vec3 vColor;
                    varying float vPhase;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        
                        // Soft glow falloff
                        float alpha = 1.0 - (dist * 2.0);
                        alpha = pow(alpha, 1.5);
                        
                        // Add core brightness
                        vec3 finalColor = vColor * (1.0 + alpha * 0.5);
                        
                        gl_FragColor = vec4(finalColor, alpha * 0.8);
                    }
                `;
                
                const particleMaterial = new THREE.ShaderMaterial({
                    uniforms: {},
                    vertexShader: particleVertexShader,
                    fragmentShader: particleFragmentShader,
                    transparent: true,
                    vertexColors: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                
                const particles = new THREE.Points(particleGeometry, particleMaterial);
                scene.add(particles);
                particlesRef.current = { mesh: particles, phases, positions };
                
                // ═══════════════════════════════════════════════════════════════
                // HEXADIC STATION NODES (1-2-4-5-7-8 Rodin positions)
                // ═══════════════════════════════════════════════════════════════
                const hexadicStations = [1, 2, 4, 5, 7, 8];
                const nodeGroup = new THREE.Group();
                nodesRef.current = [];
                
                hexadicStations.forEach((station) => {
                    const angle = (station / 9) * Math.PI * 2;
                    const x = Math.cos(angle) * torusMajorRadius;
                    const z = Math.sin(angle) * torusMajorRadius;
                    
                    // Node core (glowing sphere)
                    const nodeGeometry = new THREE.SphereGeometry(0.18, 32, 32);
                    const nodeMaterial = new THREE.MeshBasicMaterial({
                        color: 0xC084FC,
                        transparent: true,
                        opacity: 0.9
                    });
                    const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
                    node.position.set(x, 0, z);
                    nodeGroup.add(node);
                    
                    // Outer glow ring
                    const ringGeometry = new THREE.RingGeometry(0.22, 0.35, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0xC084FC,
                        transparent: true,
                        opacity: 0.4,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.set(x, 0, z);
                    ring.rotation.x = Math.PI / 2;
                    nodeGroup.add(ring);
                    
                    // Bloom/halo effect
                    const haloGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                    const haloMaterial = new THREE.MeshBasicMaterial({
                        color: 0xC084FC,
                        transparent: true,
                        opacity: 0.15
                    });
                    const halo = new THREE.Mesh(haloGeometry, haloMaterial);
                    halo.position.set(x, 0, z);
                    nodeGroup.add(halo);
                    
                    nodesRef.current.push({ node, ring, halo, station, baseY: 0 });
                });
                
                nodeGroup.rotation.x = Math.PI / 5;
                scene.add(nodeGroup);
                
                // ═══════════════════════════════════════════════════════════════
                // LIGHTING - Plasma Containment Field Aesthetic
                // ═══════════════════════════════════════════════════════════════
                const ambientLight = new THREE.AmbientLight(0x111122, 0.5);
                scene.add(ambientLight);
                
                // Golden key light
                const goldenLight = new THREE.PointLight(0xD4AF37, 1.5, 20);
                goldenLight.position.set(5, 5, 5);
                scene.add(goldenLight);
                
                // Teal fill light
                const tealLight = new THREE.PointLight(0x20B2AA, 1.0, 20);
                tealLight.position.set(-5, -2, -5);
                scene.add(tealLight);
                
                // Magenta accent
                const magentaLight = new THREE.PointLight(0xC084FC, 0.5, 15);
                magentaLight.position.set(0, -5, 3);
                scene.add(magentaLight);
                
                // ═══════════════════════════════════════════════════════════════
                // ANIMATION LOOP
                // ═══════════════════════════════════════════════════════════════
                const animate = () => {
                    animationRef.current = requestAnimationFrame(animate);
                    timeRef.current += 0.016;
                    const time = timeRef.current;
                    
                    // Update torus shader
                    if (torusRef.current) {
                        torusRef.current.material.uniforms.uTime.value = time;
                        torusRef.current.rotation.y += 0.001;
                    }
                    
                    // Animate particles - circulation flow
                    if (particlesRef.current) {
                        const { mesh, phases, positions } = particlesRef.current;
                        const posAttr = mesh.geometry.attributes.position;
                        
                        for (let i = 0; i < PARTICLE_COUNT; i++) {
                            // Flow around the torus
                            const basePhase = phases[i];
                            const flowSpeed = 0.3 + (i % 10) * 0.02; // Varied speeds
                            const u = basePhase + time * flowSpeed;
                            const v = (i / PARTICLE_COUNT) * Math.PI * 2 + time * 0.5;
                            
                            // Add turbulence (curl noise approximation)
                            const turbulence = Math.sin(u * 3 + time) * 0.1 + Math.cos(v * 2 + time * 0.7) * 0.1;
                            
                            const r = torusMinorRadius + turbulence;
                            const x = (torusMajorRadius + r * Math.cos(v)) * Math.cos(u);
                            const y = r * Math.sin(v);
                            const z = (torusMajorRadius + r * Math.cos(v)) * Math.sin(u);
                            
                            // Apply tilt
                            const tiltAngle = Math.PI / 5;
                            posAttr.array[i * 3] = x;
                            posAttr.array[i * 3 + 1] = y * Math.cos(tiltAngle) - z * Math.sin(tiltAngle) * 0.3;
                            posAttr.array[i * 3 + 2] = y * Math.sin(tiltAngle) + z * Math.cos(tiltAngle);
                        }
                        posAttr.needsUpdate = true;
                    }
                    
                    // Animate hexadic nodes - pulsing glow
                    nodesRef.current.forEach((nodeData, idx) => {
                        const pulse = Math.sin(time * 2 + idx * 0.5) * 0.5 + 0.5;
                        nodeData.node.material.opacity = 0.7 + pulse * 0.3;
                        nodeData.halo.material.opacity = 0.1 + pulse * 0.15;
                        nodeData.ring.material.opacity = 0.3 + pulse * 0.2;
                        
                        // Slight vertical oscillation
                        const yOffset = Math.sin(time * 1.5 + idx) * 0.05;
                        nodeData.node.position.y = nodeData.baseY + yOffset;
                        nodeData.ring.position.y = nodeData.baseY + yOffset;
                        nodeData.halo.position.y = nodeData.baseY + yOffset;
                    });
                    
                    renderer.render(scene, camera);
                };
                
                animate();
                
                // Handle resize
                const handleResize = () => {
                    if (!containerRef.current) return;
                    const w = containerRef.current.clientWidth;
                    const h = containerRef.current.clientHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                };
                window.addEventListener('resize', handleResize);
                
                setIsLoaded(true);
                console.log('TORUS ENGINE: ✓ Plasma Containment Field Active');
            };
            
            return (
                <div className="torus-panel">
                    <div className="torus-header">
                        <div className="torus-header__left">
                            <span className="torus-title">⚡ TORUS ENGINE</span>
                            <span className="torus-subtitle">v2.2 Plasma Containment Field</span>
                            {error && <span style={{color: 'var(--color-red)', marginLeft: '12px', fontSize: '10px'}}>⚠️ {error}</span>}
                            {isLoaded && <span style={{color: 'var(--color-golden)', marginLeft: '12px', fontSize: '10px'}}>✓ ACTIVE</span>}
                        </div>
                        <div className="torus-controls">
                            <div className="torus-stat">
                                <span>Particles:</span>
                                <span className="torus-stat__value">{particleCount.toLocaleString()}</span>
                            </div>
                            <div className="torus-stat">
                                <span>Stations:</span>
                                <span className="torus-stat__value">1-2-4-5-7-8</span>
                            </div>
                            <div className="torus-stat">
                                <span>Flow:</span>
                                <span className="torus-stat__value">{isLoaded ? 'Circulating' : '...'}</span>
                            </div>
                        </div>
                    </div>
                    <div className="torus-viz" ref={containerRef}>
                        <canvas ref={canvasRef} id="torusCanvas"></canvas>
                        {!isLoaded && !error && (
                            <div className="torus-overlay">
                                <div className="torus-overlay__icon">⚡</div>
                                <div className="torus-overlay__text">Initializing Plasma Field...</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }
        
        // NODE CARD COMPONENT
        function NodeCard({ node, type, isActive, onClick, isInArm }) {
            const cardClass = `node-card node-card--${type}${isActive ? ' node-card--active' : ''}`;
            const formatCoords = () => `θ:${node.theta}° r:${node.ring} W:${node.w}`;
            
            return (
                <div className={cardClass} onClick={() => onClick(node)} style={{ opacity: isInArm ? 1 : 0.5 }}>
                    {node.pendingInsight && <div className="insight-indicator insight-indicator--pending"></div>}
                    {node.hasInsights && !node.pendingInsight && <div className="insight-indicator"></div>}
                    <div className="node-card__header">
                        <span className="node-card__id">{node.id}</span>
                        <span className="node-card__coords">{formatCoords()}</span>
                    </div>
                    <div className="node-card__title">{node.title}</div>
                    <div className="node-card__meta">
                        <span className="node-card__tag node-card__tag--zone">{node.zone}</span>
                        <span className={`node-card__tag node-card__tag--${node.status === 'pending' ? 'pending' : 'status'}`}>{node.status}</span>
                        {node.w > 0 && <span className="node-card__tag node-card__tag--w-layer">W-{node.w}</span>}
                        {node.parent && <span className="node-card__tag" style={{ background: 'rgba(212,175,55,0.12)', color: '#D4AF37' }}>↑ {node.parent}</span>}
                    </div>
                </div>
            );
        }
        
        // PANEL COMPONENT
        function Panel({ title, titleClass, badgeClass, nodes, armTheta, armDiameter, focusedTree, setFocusedTree }) {
            const [activeNode, setActiveNode] = useState(null);
            
            const isInArmRange = (node) => {
                const halfDiameter = armDiameter / 2;
                const minTheta = (armTheta - halfDiameter + 360) % 360;
                const maxTheta = (armTheta + halfDiameter) % 360;
                if (minTheta < maxTheta) return node.theta >= minTheta && node.theta <= maxTheta;
                return node.theta >= minTheta || node.theta <= maxTheta;
            };
            
            const filteredNodes = focusedTree ? nodes.filter(n => n.id.startsWith(focusedTree) || n.parent === focusedTree) : nodes;
            const nodesInArm = filteredNodes.filter(isInArmRange);
            
            const handleNodeClick = (node) => {
                setActiveNode(node);
                if (node.zone === 'sync' && !focusedTree) setFocusedTree(node.id);
            };
            
            const handleBack = () => { setFocusedTree(null); setActiveNode(null); };
            
            return (
                <div className="panel">
                    <div className="panel-header">
                        <div className="panel-header__left">
                            <button className={`panel-back ${focusedTree ? 'visible' : ''}`} onClick={handleBack} title="Back">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="15 18 9 12 15 6"></polyline></svg>
                            </button>
                            <span className={`panel-title ${titleClass}`}>{focusedTree ? `${title} › ${focusedTree}` : title}</span>
                            <span className={`panel-badge ${badgeClass}`}>{nodesInArm.length} in view</span>
                        </div>
                        <div className="panel-header__right"><span className="panel-stat">{filteredNodes.length} total</span></div>
                    </div>
                    <div className="panel-content">
                        {focusedTree && (
                            <div className="tree-header">
                                <div className="tree-breadcrumb">
                                    <span className="tree-breadcrumb__item" onClick={handleBack}>All</span>
                                    <span className="tree-breadcrumb__sep">›</span>
                                    <span className="tree-breadcrumb__item tree-breadcrumb__item--active">{focusedTree}</span>
                                </div>
                            </div>
                        )}
                        {nodesInArm.length === 0 ? (
                            <div className="empty-state">
                                <div className="empty-state__icon">
                                    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
                                </div>
                                <div className="empty-state__title">No nodes in arm range</div>
                                <div className="empty-state__subtitle">Rotate the Metatron arm (θ) or expand the diameter</div>
                            </div>
                        ) : nodesInArm.map(node => <NodeCard key={node.id} node={node} type={title.toLowerCase()} isActive={activeNode?.id === node.id} onClick={handleNodeClick} isInArm={true} />)}
                        {filteredNodes.filter(n => !isInArmRange(n)).map(node => <NodeCard key={node.id} node={node} type={title.toLowerCase()} isActive={activeNode?.id === node.id} onClick={handleNodeClick} isInArm={false} />)}
                    </div>
                </div>
            );
        }
        
        // MAIN APP
        function App() {
            const [armTheta, setArmTheta] = useState(90);
            const [armDiameter, setArmDiameter] = useState(90);
            const [syncFocusedTree, setSyncFocusedTree] = useState(null);
            const [integrationFocusedTree, setIntegrationFocusedTree] = useState(null);
            
            return (
                <React.Fragment>
                    <div className="header">
                        <div className="header-left">
                            <div className="header-title">
                                <div className="header-title__icon">
                                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>
                                </div>
                                <span className="header-title__text">METATRON Radial Database</span>
                                <span className="header-title__badge">W=0</span>
                            </div>
                        </div>
                        <div className="arm-control">
                            <div className="arm-stat">
                                <span className="arm-stat__label">θ</span>
                                <input type="range" min="0" max="360" value={armTheta} onChange={e => setArmTheta(+e.target.value)} />
                                <span className="arm-stat__value">{armTheta}°</span>
                            </div>
                            <div className="arm-stat">
                                <span className="arm-stat__label">⌀</span>
                                <input type="range" min="10" max="180" value={armDiameter} onChange={e => setArmDiameter(+e.target.value)} />
                                <span className="arm-stat__value">{armDiameter}°</span>
                            </div>
                        </div>
                        <div className="header-stats">
                            <div className="header-stat"><span>Sync:</span><span className="header-stat-value">{DEMO_SYNC_NODES.length}</span></div>
                            <div className="header-stat"><span>Integration:</span><span className="header-stat-value">{DEMO_INTEGRATION_NODES.length}</span></div>
                        </div>
                    </div>
                    <div className="main-container">
                        <div className="top-panels">
                            <Panel title="SYNC" titleClass="panel-title--sync" badgeClass="" nodes={DEMO_SYNC_NODES} armTheta={armTheta} armDiameter={armDiameter} focusedTree={syncFocusedTree} setFocusedTree={setSyncFocusedTree} />
                            <Panel title="INTEGRATION" titleClass="panel-title--integration" badgeClass="panel-badge--blue" nodes={DEMO_INTEGRATION_NODES} armTheta={armTheta} armDiameter={armDiameter} focusedTree={integrationFocusedTree} setFocusedTree={setIntegrationFocusedTree} />
                        </div>
                        <TorusEngine />
                    </div>
                </React.Fragment>
            );
        }
        
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>
